//6 kyu
// Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. 
//The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.

//Inelegant but I'm amazed I got it to work so quickly (<20minutes)

using System;
using System.Linq;

public class Kata
{
  public static int DuplicateCount(string str)
  {
    int endCount = 0;
    string singles = new String(str.ToLower().Distinct().ToArray());
    foreach (char c in singles)
      {
        int doubleCounter = 0;
      foreach (char x in str)
        {
          if (char.ToUpper(c) == char.ToUpper(x)) {
            doubleCounter++;
          }
        }
        if (doubleCounter > 1)
          {
            endCount++;
          }
      }
      return endCount;
  }
}


//tests
using System;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;

[TestFixture]
public class KataTest
{
  public static int Solution(string str)
  {
    str = String.Join("", str.ToLower().OrderBy(c => c));
    return Regex.Matches(str, @"(.)\1+").Count;
  }
  
  [Test]
  public void KataTests()
  {
    Assert.AreEqual(0, Kata.DuplicateCount(""));
    Assert.AreEqual(0, Kata.DuplicateCount("abcde"));
    Assert.AreEqual(2, Kata.DuplicateCount("aabbcde"));
    Assert.AreEqual(2, Kata.DuplicateCount("aabBcde"), "should ignore case");
    Assert.AreEqual(1, Kata.DuplicateCount("Indivisibility"));
    Assert.AreEqual(2, Kata.DuplicateCount("Indivisibilities"), "characters may not be adjacent");
  }
  
  [Test]
  public void RandomTests()
  {
    var random = new Random();
    string randomStr;
    for (int i = 0; i < 10; i++)
    {
      randomStr =
        String.Join("", Enumerable.Range(0, 20).Select((o, x) => (char)random.Next('a', 'z') + (char)random.Next('A', 'Z')));

      Assert.AreEqual(Solution(randomStr), Kata.DuplicateCount(randomStr));
    }
  }
}
